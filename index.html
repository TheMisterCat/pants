<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SMRT Radio</title>
<style>
  body { font-family: sans-serif; background: #121212; color: #eee; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 0; }
  h1 { margin: 1em 0; }
  #controls { display: flex; align-items: center; gap: 1em; margin-bottom: 1em; flex-wrap: wrap; }
  button { padding: 0.5em 1em; }
  #volume, #filterFreq, #progress { width: 200px; }
  #playlist { margin-top: 1em; width: 80%; max-width: 600px; }
  #playlist div { padding: 0.5em; cursor: pointer; border-bottom: 1px solid #333; }
  #playlist .playing { background: #333; }
</style>
</head>
<body>
<h1>SMRT Radio</h1>
<div id="controls">
  <button id="prev">Prev</button>
  <button id="playPause">Play</button>
  <button id="stop">Stop</button>
  <button id="next">Next</button>
  <label>Volume:<input type="range" id="volume" min="0" max="1" step="0.01" value="0.3"></label>
  <label>Treble:<input type="range" id="filterFreq" min="500" max="8000" step="10" value="4000"></label>
</div>
<input type="range" id="progress" min="0" max="1" step="0.001" value="0">
<div id="playlist"></div>

<script>
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
let masterGainNode = audioContext.createGain();
masterGainNode.gain.value = 0.3; // Safe default volume
masterGainNode.connect(audioContext.destination);

let compressor = audioContext.createDynamicsCompressor();
compressor.threshold.setValueAtTime(-18, audioContext.currentTime);
compressor.knee.setValueAtTime(15, audioContext.currentTime);
compressor.ratio.setValueAtTime(2, audioContext.currentTime);
compressor.attack.setValueAtTime(0.05, audioContext.currentTime);
compressor.release.setValueAtTime(0.3, audioContext.currentTime);
compressor.connect(masterGainNode);

let trackList = [
  "track1.dfpwm",
  "track2.dfpwm",
  "track3.dfpwm"
]; // Replace with actual DFPWM URLs

let trackBuffers = {};
let currentSource = null;
let currentTrackIndex = 0;
let isPlaying = false;
let lastClickTime = 0;

const volumeSlider = document.getElementById("volume");
const filterSlider = document.getElementById("filterFreq");
const progressSlider = document.getElementById("progress");
const playlistDiv = document.getElementById("playlist");

// --- Playback functions ---
function stopCurrentTrack() {
  if (currentSource) {
    try { currentSource.stop(); } catch(e) {}
    currentSource.disconnect();
    currentSource = null;
  }
  isPlaying = false;
  updatePlayButton();
}

function highlightPlaying() {
  Array.from(playlistDiv.children).forEach((el, i) => {
    el.classList.toggle("playing", i === currentTrackIndex);
  });
}

async function loadTrack(idx) {
  if (trackBuffers[idx]) return trackBuffers[idx];
  const url = trackList[idx];
  const response = await fetch(url);
  const dfpwmData = new Uint8Array(await response.arrayBuffer());
  const wavBuffer = dfpwmDecodeToPCM(dfpwmData); // Replace with working browser decoder
  const audioBuffer = await audioContext.decodeAudioData(wavBuffer.buffer);
  trackBuffers[idx] = audioBuffer;
  return audioBuffer;
}

function playTrack(idx) {
  const now = Date.now();
  if (now - lastClickTime < 200) return; // safety ignore 200ms
  lastClickTime = now;

  stopCurrentTrack();
  currentTrackIndex = idx;
  highlightPlaying();

  loadTrack(idx).then(buffer => {
    const source = audioContext.createBufferSource();
    source.buffer = buffer;

    // --- Audio filters ---
    const lowpass = audioContext.createBiquadFilter();
    lowpass.type = "lowpass";
    lowpass.frequency.value = filterSlider.value;

    const highShelf = audioContext.createBiquadFilter();
    highShelf.type = "highshelf";
    highShelf.frequency.value = 10000;
    highShelf.gain.value = -4; // gentle high frequency cut

    source.connect(lowpass);
    lowpass.connect(highShelf);
    highShelf.connect(compressor);

    source.start(0);
    currentSource = source;
    isPlaying = true;
    updatePlayButton();

    source.onended = () => {
      currentSource = null;
      isPlaying = false;
      updatePlayButton();
      nextTrack();
    };
  });
}

function playPauseTrack() {
  if (isPlaying) stopCurrentTrack();
  else playTrack(currentTrackIndex);
}

function nextTrack() {
  playTrack((currentTrackIndex + 1) % trackList.length);
}

function prevTrack() {
  playTrack((currentTrackIndex - 1 + trackList.length) % trackList.length);
}

function updatePlayButton() {
  document.getElementById("playPause").textContent = isPlaying ? "Pause" : "Play";
}

// --- UI events ---
volumeSlider.addEventListener("input", () => {
  masterGainNode.gain.value = volumeSlider.value;
});

filterSlider.addEventListener("input", () => {
  // Applied dynamically on next track
});

document.getElementById("playPause").addEventListener("click", playPauseTrack);
document.getElementById("stop").addEventListener("click", () => {
  stopCurrentTrack();
  currentTrackIndex = 0; // stops auto-play
});
document.getElementById("next").addEventListener("click", nextTrack);
document.getElementById("prev").addEventListener("click", prevTrack);

// --- Populate playlist ---
trackList.forEach((name, i) => {
  const div = document.createElement("div");
  div.textContent = name;
  div.addEventListener("click", () => playTrack(i));
  playlistDiv.appendChild(div);
});

// --- Progress bar update ---
setInterval(() => {
  if (currentSource && isPlaying) {
    progressSlider.value = Math.min(1, audioContext.currentTime / currentSource.buffer.duration);
  } else {
    progressSlider.value = 0;
  }
}, 200);

// --- Placeholder decoder ---
function dfpwmDecodeToPCM(dfpwm) {
  // Keep your working browser decoder here
  // Returns Float32Array or ArrayBuffer ready for decodeAudioData
  return new Float32Array(dfpwm.length * 4);
}
</script>
</body>
</html>
