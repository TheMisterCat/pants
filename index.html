<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SMRT Radio</title>
<style>
  body { font-family: sans-serif; margin: 20px; background:#111; color:#eee; }
  h1 { text-align:center; }
  #controls { display:flex; justify-content:center; gap:10px; margin-bottom:10px; }
  #progress { width: 80%; margin: 0 auto; display:block; }
  #volume { width: 150px; }
  #playlist { margin-top:20px; max-height:300px; overflow-y:auto; border-top:1px solid #444; padding-top:10px;}
  .track { cursor:pointer; padding:5px; }
  .track.active { background:#444; }
</style>
</head>
<body>
<h1>SMRT Radio</h1>

<div id="controls">
  <button id="prev">⏮ Prev</button>
  <button id="play">▶ Play</button>
  <button id="pause">⏸ Pause</button>
  <button id="stop">⏹ Stop</button>
  <button id="next">⏭ Next</button>
  Volume: <input type="range" id="volume" min="0" max="1" step="0.01" value="0.5">
</div>
<input type="range" id="progress" value="0" min="0" max="100">

<div id="playlist"></div>

<script>
// --- CONFIG ---
const USER = "TheMisterCat";
const REPO = "pants";
const AUDIO_DIR = ""; // root

// --- GLOBALS ---
let audioContext = new (window.AudioContext || window.webkitAudioContext)();
let gainNode = audioContext.createGain();
gainNode.connect(audioContext.destination);
gainNode.gain.value = 0.5;

let currentBufferSource = null;
let currentTrackIndex = 0;
let playlist = [];
let isPlaying = false;

// --- DFPWM Decoder (full dynamic range) ---
function decodeDFPWM(bytes) {
  let charge = 0;
  const strength = 0.25;
  const output = new Float32Array(bytes.length * 8);
  let sampleIndex = 0;

  for (let byte of bytes) {
    for (let i = 0; i < 8; i++) {
      const bit = (byte >> i) & 1;
      const target = bit ? 1 : -1;
      charge += (target - charge) * strength;

      // Slight fade-in first sample to avoid clicks
      output[sampleIndex++] = charge * 0.95 + (sampleIndex < 5 ? sampleIndex * 0.01 : 0);
    }
  }
  return output;
}

// --- Load playlist from GitHub ---
async function loadPlaylist() {
  const url = `https://api.github.com/repos/${USER}/${REPO}/contents/${AUDIO_DIR}`;
  const res = await fetch(url);
  const data = await res.json();
  playlist = data.filter(f => f.name.endsWith(".dfpwm"));
  renderPlaylist();
}
function renderPlaylist() {
  const container = document.getElementById("playlist");
  container.innerHTML = "";
  playlist.forEach((track, i) => {
    const div = document.createElement("div");
    div.textContent = track.name;
    div.className = "track" + (i===currentTrackIndex ? " active" : "");
    div.onclick = () => { playTrack(i); };
    container.appendChild(div);
  });
}

// --- Fetch and decode a dfpwm file ---
async function fetchAndDecode(track) {
  const url = `https://raw.githubusercontent.com/${USER}/${REPO}/main/${AUDIO_DIR}${track.name}`;
  const res = await fetch(url);
  const arrayBuffer = await res.arrayBuffer();
  const bytes = new Uint8Array(arrayBuffer);
  const floatSamples = decodeDFPWM(bytes);

  const audioBuffer = audioContext.createBuffer(1, floatSamples.length, 48000);
  audioBuffer.getChannelData(0).set(floatSamples);
  return audioBuffer;
}

// --- Playback ---
async function playTrack(index) {
  stopTrack();
  currentTrackIndex = index;
  updateActiveTrack();

  const buffer = await fetchAndDecode(playlist[index]);
  const source = audioContext.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(0);
  source.onended = () => { nextTrack(); };
  currentBufferSource = source;
  isPlaying = true;
}

function stopTrack() {
  if (currentBufferSource) {
    currentBufferSource.stop();
    currentBufferSource.disconnect();
    currentBufferSource = null;
    isPlaying = false;
  }
}

function pauseTrack() {
  if (audioContext.state === "running") audioContext.suspend();
  else audioContext.resume();
}

function nextTrack() {
  currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
  playTrack(currentTrackIndex);
}
function prevTrack() {
  currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
  playTrack(currentTrackIndex);
}

function updateActiveTrack() {
  document.querySelectorAll(".track").forEach((el,i)=>{
    el.classList.toggle("active", i===currentTrackIndex);
  });
}

// --- Volume Control ---
document.getElementById("volume").addEventListener("input", e=>{
  gainNode.gain.value = parseFloat(e.target.value);
});

// --- Control Buttons ---
document.getElementById("play").onclick = () => playTrack(currentTrackIndex);
document.getElementById("stop").onclick = stopTrack;
document.getElementById("pause").onclick = pauseTrack;
document.getElementById("next").onclick = nextTrack;
document.getElementById("prev").onclick = prevTrack;

// --- Initialize ---
loadPlaylist();
</script>
</body>
</html>
