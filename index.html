<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SMRT Radio</title>
<link rel="icon" href="data:,">
<style>
  body { font-family: sans-serif; background: #111; color: #eee; margin: 0; display: flex; flex-direction: column; align-items: center; }
  header { text-align: center; margin: 1em; }
  #controls { display: flex; gap: 10px; margin: 1em; align-items: center; flex-wrap: wrap; justify-content: center; }
  button { padding: 0.5em 1em; }
  #sliders { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
  #playlist { margin-top: 1em; width: 90%; max-width: 800px; overflow-y: auto; max-height: 300px; }
  .track { padding: 0.5em; cursor: pointer; border-bottom: 1px solid #444; }
  .track.playing { background: #333; }
  #progress { width: 300px; margin-top: 1em; }
  #waveform { width: 90%; max-width: 800px; height: 100px; background: #222; margin-top: 1em; }
</style>
</head>
<body>
<header><h1>SMRT Radio</h1></header>

<div id="controls">
  <button id="prev">Prev</button>
  <button id="play">Play</button>
  <button id="pause">Pause</button>
  <button id="stop">Stop</button>
  <button id="next">Next</button>
  <div id="sliders">
    <label>Volume: <input type="range" id="volume" min="0" max="1" step="0.01" value="0.2"></label>
    <label>Low‑pass: <input type="range" id="filter" min="500" max="20000" step="100" value="12000"></label>
  </div>
</div>

<progress id="progress" value="0" max="1"></progress>
<canvas id="waveform"></canvas>
<div id="playlist"></div>

<script type="module">
// --- CONFIG ---
const REPO = "TheMisterCat/pants";
const AUDIO_DIR = "";
const VOLUME_SCALING = 0.2;

// --- AUDIO SETUP ---
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const masterGainNode = audioContext.createGain();
const filterNode = audioContext.createBiquadFilter();
filterNode.type = "lowpass";
filterNode.frequency.value = 12000;
masterGainNode.connect(filterNode);
filterNode.connect(audioContext.destination);

const analyser = audioContext.createAnalyser();
analyser.fftSize = 2048;
filterNode.connect(analyser);

// --- PLAYLIST & TRACK STATE ---
let currentSource = null;
let currentTrackIndex = 0;
let trackBuffers = [];
let playlist = [];
let lastButtonTime = 0;
const BUTTON_COOLDOWN = 250;

// --- HIGH‑QUALITY DFPWM DECODER IMPLEMENTATION ---
class DFPWMDecoderSpec {
  constructor() {
    this.q = 0;        // “charge” state
    this.s = 1;        // “strength” state
    this.bPrev = 0;    // previous bit
    // constants for 8‑bit sample mode
    this.Ri = 7;
    this.Rd = 20;
  }

  decode(bytes) {
    const out = new Float32Array(bytes.length * 8);
    let outIdx = 0;

    for (let byteIdx = 0; byteIdx < bytes.length; byteIdx++) {
      const byte = bytes[byteIdx];
      for (let bitIdx = 0; bitIdx < 8; bitIdx++) {
        const b = (byte >> bitIdx) & 1;
        const t = b ? 127 : -128;

        // charge update
        let qPrime = this.q + ((this.s * (t - this.q) + 128) >> 8);
        if (qPrime === this.q && this.q !== t) {
          if (t < this.q) qPrime--;
          else if (t > this.q) qPrime++;
        }
        this.q = qPrime;

        // strength update
        let r, z;
        if (b === this.bPrev) {
          r = this.Ri;
          z = 255;
        } else {
          r = this.Rd;
          z = 0;
        }
        let sPrime = this.s + ((r * (z - this.s) + 128) >> 8);
        if (sPrime === this.s && this.s !== z) {
          if (z < this.s) sPrime--;
          else if (z > this.s) sPrime++;
        }
        this.s = sPrime;

        this.bPrev = b;

        // output sample normalization to Float32
        // map q (signed 8-bit range) to [-1.0‑1.0] then apply volume scaling
        out[outIdx++] = (this.q / 128) * VOLUME_SCALING;
      }
    }
    return out;
  }
}

const decoder = new DFPWMDecoderSpec();

// --- FETCH PLAYLIST ---
async function fetchPlaylist() {
  const url = `https://api.github.com/repos/${REPO}/contents/${AUDIO_DIR}`;
  const res = await fetch(url);
  const files = await res.json();
  playlist = files.filter(f => f.name.endsWith(".dfpwm")).map(f => f.name);

  const listDiv = document.getElementById("playlist");
  listDiv.innerHTML = "";
  playlist.forEach((name, idx) => {
    const div = document.createElement("div");
    div.textContent = name;
    div.classList.add("track");
    div.onclick = () => safePlay(idx);
    listDiv.appendChild(div);
  });
}

// --- LOAD & DECODE TRACK ---
async function loadTrack(idx) {
  const url = `https://raw.githubusercontent.com/${REPO}/main/${AUDIO_DIR}${playlist[idx]}`;
  const res = await fetch(url);
  const arrayBuffer = await res.arrayBuffer();
  const bytes = new Uint8Array(arrayBuffer);

  const floatData = decoder.decode(bytes);

  const buffer = audioContext.createBuffer(1, floatData.length, 48000);
  buffer.copyToChannel(floatData, 0, 0);
  trackBuffers[idx] = buffer;
}

// --- PLAYBACK LOGIC ---
async function playTrack(idx) {
  if (currentSource) currentSource.stop();
  currentTrackIndex = idx;
  highlightPlaying();
  if (!trackBuffers[idx]) await loadTrack(idx);

  const source = audioContext.createBufferSource();
  source.buffer = trackBuffers[idx];
  source.connect(masterGainNode);
  source.start(0);
  currentSource = source;
  source.onended = () => {
    currentSource = null;
    nextTrack();
  };
}

// --- BUTTON SAFETY & CONTROL ---
function safeAction(action) {
  const now = performance.now();
  if (now - lastButtonTime < BUTTON_COOLDOWN) return;
  lastButtonTime = now;
  action();
}
function safePlay(idx) { safeAction(() => playTrack(idx)); }
function safePause() { safeAction(stopTrack); }
function safeStop() { safeAction(stopTrack); }
function safeNext() { safeAction(nextTrack); }
function safePrev() { safeAction(prevTrack); }

function stopTrack() {
  if (currentSource) currentSource.stop();
  currentSource = null;
}

function nextTrack() {
  let next = (currentTrackIndex + 1) % playlist.length;
  playTrack(next);
}

function prevTrack() {
  let prev = (currentTrackIndex - 1 + playlist.length) % playlist.length;
  playTrack(prev);
}

function highlightPlaying() {
  document.querySelectorAll(".track").forEach((el, idx) => {
    el.classList.toggle("playing", idx === currentTrackIndex);
  });
}

// --- UI Event Listeners ---
document.getElementById("play").onclick = () => safePlay(currentTrackIndex);
document.getElementById("pause").onclick = safePause;
document.getElementById("stop").onclick = safeStop;
document.getElementById("next").onclick = safeNext;
document.getElementById("prev").onclick = safePrev;

document.getElementById("volume").addEventListener("input", e => {
  masterGainNode.gain.value = parseFloat(e.target.value);
});
document.getElementById("filter").addEventListener("input", e => {
  filterNode.frequency.value = parseFloat(e.target.value);
});

// --- WAVEFORM VISUALIZATION ---
const canvas = document.getElementById("waveform");
const ctx = canvas.getContext("2d");
function drawWaveform() {
  requestAnimationFrame(drawWaveform);
  const bufferLength = analyser.fftSize;
  const dataArray = new Uint8Array(bufferLength);
  analyser.getByteTimeDomainData(dataArray);

  ctx.fillStyle = "#222";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.lineWidth = 2;
  ctx.strokeStyle = "#0f0";
  ctx.beginPath();
  const sliceWidth = canvas.width / bufferLength;
  let x = 0;
  for (let i = 0; i < bufferLength; i++) {
    const v = dataArray[i] / 128.0;
    const y = v * canvas.height / 2;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
    x += sliceWidth;
  }
  ctx.lineTo(canvas.width, canvas.height/2);
  ctx.stroke();
}
drawWaveform();

// --- INIT ---
fetchPlaylist();
</script>
</body>
</html>
