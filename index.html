<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>SMRT Radio</title>
<style>
  body { font-family: sans-serif; margin:2em; background:#f5f5f5; color:#222; }
  h1 { margin-bottom: 0.5em; }
  #controls button { margin: 0.2em; }
  #volume, #filterFreq { width: 150px; }
  #progressContainer { width: 300px; height: 10px; background: #ddd; margin-top: 0.5em; position: relative; cursor: pointer; }
  #progress { height: 100%; width: 0%; background: #3a9; }
  #trackList { margin-top: 2em; list-style: none; padding: 0; }
  #trackList li { cursor: pointer; padding: 0.2em 0; }
  #trackList li.current { font-weight: bold; color: #3a9; }
</style>
</head>
<body>
<h1>SMRT Radio</h1>

<!-- Controls -->
<div id="controls">
  <button id="prev">Prev</button>
  <button id="playPause">Play</button>
  <button id="stop">Stop</button>
  <button id="next">Next</button>
  Volume: <input type="range" id="volume" min="0" max="1" step="0.01" value="0.25">
  Treble: <input type="range" id="filterFreq" min="1000" max="16000" step="500" value="8000">
</div>

<!-- Progress bar -->
<div id="progressContainer">
  <div id="progress"></div>
</div>

<!-- Track list -->
<ul id="trackList"></ul>

<script type="module">
// ==================== Improved DFPWM Decoder ====================
export function decodeDFPWM(bytes) {
  let charge = 0;
  const strength = 0.25;
  const output = new Float32Array(bytes.length * 8);
  let sampleIndex = 0;

  const MAX_GAIN = 0.15;  // Reduced gain to prevent oversaturation
  const fadeSamples = 32;

  for (let byte of bytes) {
    for (let i = 0; i < 8; i++) {
      const bit = (byte >> i) & 1;
      const target = bit ? 1 : -1;

      // Smooth transition
      charge += (target - charge) * strength;

      // Soft clipping / dynamic compression
      let sample = charge * MAX_GAIN;
      if (sample > 1) sample = 1;
      else if (sample < -1) sample = -1;

      // Optional fade-in for first few samples to prevent clicks
      const fadeFactor = sampleIndex < fadeSamples ? sampleIndex / fadeSamples : 1;

      // Optional smoothing (average with previous)
      if (sampleIndex > 0) sample = 0.8 * sample + 0.2 * output[sampleIndex - 1];

      output[sampleIndex++] = sample * fadeFactor;
    }
  }
  return output;
}

// ==================== Player Script ====================
const USER = "TheMisterCat";
const REPO = "pants";
const BRANCH = "main";

let playlist = [];
let currentIndex = 0;

let audioCtx = null;
let gainNode = null;
let audioFilter = null;
let source = null;

let isPlaying = false;
let isLoadingTrack = false;
let trackStartTime = 0;
let pauseOffset = 0;
let trackDuration = 0;
let progressInterval = null;

const trackListEl = document.getElementById("trackList");
const playPauseBtn = document.getElementById("playPause");
const volumeSlider = document.getElementById("volume");
const filterFreqSlider = document.getElementById("filterFreq");
const progressBar = document.getElementById("progress");
const progressContainer = document.getElementById("progressContainer");

// ==================== Playlist ====================
async function fetchPlaylist() {
  const res = await fetch(`https://api.github.com/repos/${USER}/${REPO}/contents?ref=${BRANCH}`);
  const files = await res.json();
  playlist = files.filter(f => f.name.endsWith(".dfpwm")).map(f => f.name);

  trackListEl.innerHTML = "";
  playlist.forEach((name, idx) => {
    const li = document.createElement("li");
    li.textContent = name;
    li.addEventListener("click", () => playTrack(idx));
    trackListEl.appendChild(li);
  });
}

// ==================== Audio Helpers ====================
async function fetchTrackPCM(trackName) {
  const url = `https://raw.githubusercontent.com/${USER}/${REPO}/${BRANCH}/${trackName}`;
  const res = await fetch(url);
  const buffer = new Uint8Array(await res.arrayBuffer());
  return decodeDFPWM(buffer);
}

function createSource(pcm) {
  const audioBuffer = audioCtx.createBuffer(1, pcm.length, 48000);
  audioBuffer.getChannelData(0).set(pcm);

  const newSource = audioCtx.createBufferSource();
  newSource.buffer = audioBuffer;
  newSource.connect(audioFilter);
  newSource.onended = () => {
    isPlaying = false;
    stopProgressUpdater();
    playNextTrack();
  };

  return { newSource, duration: audioBuffer.duration };
}

// ==================== Playback ====================
async function playTrack(index) {
  if (isLoadingTrack) return;
  isLoadingTrack = true;

  stopTrack();
  currentIndex = index;
  highlightCurrentTrack();

  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    gainNode = audioCtx.createGain();
    gainNode.gain.value = parseFloat(volumeSlider.value);

    const filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = parseFloat(filterFreqSlider.value);
    filter.Q.value = 1;

    filter.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    audioFilter = filter;
  }

  try {
    const pcm = await fetchTrackPCM(playlist[currentIndex]);
    const { newSource, duration } = createSource(pcm);

    source = newSource;
    trackDuration = duration;

    source.start(0, pauseOffset);
    trackStartTime = audioCtx.currentTime - pauseOffset;
    pauseOffset = 0;
    isPlaying = true;

    startProgressUpdater();
    playPauseBtn.textContent = "Pause";
  } finally {
    isLoadingTrack = false;
  }
}

function stopTrack() {
  if (source) {
    source.stop();
    source.disconnect();
    source = null;
  }
  pauseOffset = 0;
  isPlaying = false;
  stopProgressUpdater();
  playPauseBtn.textContent = "Play";
}

function pauseTrack() {
  if (source && isPlaying) {
    source.stop();
    source.disconnect();
    pauseOffset = audioCtx.currentTime - trackStartTime;
    source = null;
    isPlaying = false;
    stopProgressUpdater();
    playPauseBtn.textContent = "Play";
  }
}

function playNextTrack() {
  currentIndex = (currentIndex + 1) % playlist.length;
  playTrack(currentIndex);
}

function playPrevTrack() {
  currentIndex = (currentIndex - 1 + playlist.length) % playlist.length;
  playTrack(currentIndex);
}

function highlightCurrentTrack() {
  Array.from(trackListEl.children).forEach((li, idx) => {
    li.classList.toggle("current", idx === currentIndex);
  });
}

// ==================== Progress ====================
function startProgressUpdater() {
  stopProgressUpdater();
  progressInterval = setInterval(() => {
    if (!isPlaying) return;
    const elapsed = audioCtx.currentTime - trackStartTime;
    const percent = Math.min(1, elapsed / trackDuration) * 100;
    progressBar.style.width = percent + "%";
  }, 100);
}

function stopProgressUpdater() {
  if (progressInterval) clearInterval(progressInterval);
  progressBar.style.width = "0%";
}

progressContainer.addEventListener("click", (e) => {
  if (!source) return;

  const rect = progressContainer.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickPercent = clickX / rect.width;

  pauseOffset = trackDuration * clickPercent;
  playTrack(currentIndex);
});

// ==================== Controls ====================
playPauseBtn.addEventListener("click", () => {
  if (isPlaying) pauseTrack();
  else playTrack(currentIndex);
});

document.getElementById("next").addEventListener("click", playNextTrack);
document.getElementById("prev").addEventListener("click", playPrevTrack);
document.getElementById("stop").addEventListener("click", stopTrack);

volumeSlider.addEventListener("input", (e) => {
  if (gainNode) gainNode.gain.value = parseFloat(e.target.value);
});

filterFreqSlider.addEventListener("input", (e) => {
  if (audioFilter) audioFilter.frequency.value = parseFloat(e.target.value);
});

// ==================== Init ====================
fetchPlaylist();
</script>
</body>
</html>
