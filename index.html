<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DFPWM Radio</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; max-width: 500px; margin: auto; }
    ul { list-style: none; padding: 0; max-height: 200px; overflow-y: auto; border: 1px solid #ccc; margin-bottom: 1rem; }
    li { padding: 0.25rem 0.5rem; cursor: pointer; }
    li.current { font-weight: bold; color: green; background: #f0f0f0; }
    button, input { margin-top: 0.5rem; margin-right: 0.5rem; }
    #progressContainer {
      width: 100%;
      height: 10px;
      background: #ccc;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 0.5rem;
    }
    #progressBar {
      width: 0;
      height: 100%;
      background: green;
    }
    #status { margin-bottom: 0.5rem; }
    @media (max-width: 500px) {
      body { padding: 1rem; }
      ul { max-height: 150px; }
    }
  </style>
</head>
<body>
  <h1>DFPWM Radio</h1>
  <p id="status">Loading playlist...</p>
  <ul id="trackList"></ul>

  <div>
    <button id="prevBtn" disabled>‚èÆ Previous</button>
    <button id="playBtn" disabled>‚ñ∂ Play</button>
    <button id="nextBtn" disabled>‚è≠ Next</button>
    <button id="shuffleBtn" disabled>üîÄ Shuffle Off</button>
  </div>

  <div>
    Volume: <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.5">
    Speed: <input type="range" id="speedControl" min="0.5" max="2" step="0.05" value="1">
  </div>

  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="timeDisplay">00:00 / 00:00</div>

  <script type="module">
    import { DfpwmDecoder } from "./js/dfpwm.min.js";

    const GITHUB_USER = "TheMisterCat";
    const GITHUB_REPO = "pants";
    const BRANCH = "main";

    const STATUS = document.getElementById("status");
    const PLAY_BTN = document.getElementById("playBtn");
    const PREV_BTN = document.getElementById("prevBtn");
    const NEXT_BTN = document.getElementById("nextBtn");
    const SHUFFLE_BTN = document.getElementById("shuffleBtn");
    const TRACK_LIST_EL = document.getElementById("trackList");
    const VOLUME_CTRL = document.getElementById("volumeControl");
    const SPEED_CTRL = document.getElementById("speedControl");
    const PROGRESS_BAR = document.getElementById("progressBar");
    const TIME_DISPLAY = document.getElementById("timeDisplay");

    let playlist = [];
    let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let gainNode = audioCtx.createGain();
    gainNode.connect(audioCtx.destination);
    gainNode.gain.value = parseFloat(VOLUME_CTRL.value);

    let currentIndex = 0;
    let isPlaying = false;
    let shuffleMode = false;
    let sourceNode = null;
    let currentBuffer = null;

    VOLUME_CTRL.addEventListener("input", () => {
      gainNode.gain.value = parseFloat(VOLUME_CTRL.value);
    });

    SPEED_CTRL.addEventListener("input", () => {
      if(sourceNode) sourceNode.playbackRate.value = parseFloat(SPEED_CTRL.value);
    });

    SHUFFLE_BTN.addEventListener("click", () => {
      shuffleMode = !shuffleMode;
      SHUFFLE_BTN.textContent = shuffleMode ? "üîÄ Shuffle On" : "üîÄ Shuffle Off";
    });

    PREV_BTN.addEventListener("click", () => {
      currentIndex = (currentIndex - 1 + playlist.length) % playlist.length;
      startTrack();
    });

    NEXT_BTN.addEventListener("click", () => {
      currentIndex = (currentIndex + 1) % playlist.length;
      startTrack();
    });

    PLAY_BTN.addEventListener("click", () => {
      if(!isPlaying) {
        startTrack();
      } else {
        stopTrack();
      }
    });

    document.addEventListener("keydown", (e) => {
      if(e.code === "Space") {
        e.preventDefault();
        PLAY_BTN.click();
      } else if(e.code === "ArrowRight") {
        NEXT_BTN.click();
      } else if(e.code === "ArrowLeft") {
        PREV_BTN.click();
      }
    });

    function displayTrackList() {
      TRACK_LIST_EL.innerHTML = "";
      playlist.forEach((track, i) => {
        const li = document.createElement("li");
        li.textContent = track.name;
        li.dataset.index = i;
        li.addEventListener("click", () => {
          currentIndex = i;
          startTrack();
        });
        TRACK_LIST_EL.appendChild(li);
      });
    }

    function highlightTrack(index) {
      TRACK_LIST_EL.querySelectorAll("li").forEach(li => li.classList.remove("current"));
      const currentLi = TRACK_LIST_EL.querySelector(`li[data-index="${index}"]`);
      if(currentLi) currentLi.classList.add("current");
    }

    async function fetchPlaylist() {
      try {
        const apiUrl = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents?ref=${BRANCH}`;
        const res = await fetch(apiUrl);
        const files = await res.json();
        playlist = files
          .filter(f => f.name.endsWith(".dfpwm"))
          .map(f => ({ name: f.name, url: f.download_url }));

        if(playlist.length === 0) {
          STATUS.textContent = "No DFPWM files found!";
        } else {
          STATUS.textContent = `Found ${playlist.length} tracks.`;
          PLAY_BTN.disabled = false;
          PREV_BTN.disabled = false;
          NEXT_BTN.disabled = false;
          SHUFFLE_BTN.disabled = false;
          displayTrackList();
        }
      } catch(err) {
        STATUS.textContent = "Failed to load playlist: " + err;
      }
    }

    async function fetchDfpwm(url) {
      const res = await fetch(url);
      const arrayBuffer = await res.arrayBuffer();
      return new Uint8Array(arrayBuffer);
    }

    async function startTrack() {
      stopTrack();
      const track = playlist[currentIndex];
      highlightTrack(currentIndex);
      STATUS.textContent = `Playing: ${track.name}`;

      const bytes = await fetchDfpwm(track.url);
      const decoder = new DfpwmDecoder();
      const audioData = decoder.decode(bytes);

      currentBuffer = audioCtx.createBuffer(1, audioData.length, 44100);
      currentBuffer.getChannelData(0).set(audioData);

      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = currentBuffer;
      sourceNode.playbackRate.value = parseFloat(SPEED_CTRL.value);
      sourceNode.connect(gainNode);

      const startTime = audioCtx.currentTime;
      isPlaying = true;
      PLAY_BTN.textContent = "‚è∏ Pause";

      function updateProgress() {
        if(!isPlaying || !currentBuffer) return;
        const elapsed = audioCtx.currentTime - startTime;
        const duration = currentBuffer.duration;
        PROGRESS_BAR.style.width = Math.min((elapsed / duration) * 100, 100) + "%";
        TIME_DISPLAY.textContent = formatTime(elapsed) + " / " + formatTime(duration);
        if(elapsed < duration) requestAnimationFrame(updateProgress);
      }
      updateProgress();

      sourceNode.onended = () => {
        isPlaying = false;
        PLAY_BTN.textContent = "‚ñ∂ Play";
        PROGRESS_BAR.style.width = "0%";
        TIME_DISPLAY.textContent = "00:00 / 00:00";
        // Next track
        if(shuffleMode) {
          currentIndex = Math.floor(Math.random() * playlist.length);
        } else {
          currentIndex = (currentIndex + 1) % playlist.length;
        }
        startTrack();
      };

      sourceNode.start();
    }

    function stopTrack() {
      if(sourceNode) {
        sourceNode.stop();
        sourceNode.disconnect();
        sourceNode = null;
      }
      isPlaying = false;
      PLAY_BTN.textContent = "‚ñ∂ Play";
    }

    function formatTime(sec) {
      const m = Math.floor(sec / 60).toString().padStart(2, "0");
      const s = Math.floor(sec % 60).toString().padStart(2, "0");
      return `${m}:${s}`;
    }

    await fetchPlaylist();
  </script>
</body>
</html>
