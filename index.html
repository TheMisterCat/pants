<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DFPWM Radio</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; max-width: 500px; margin: auto; }
    ul { list-style: none; padding: 0; max-height: 200px; overflow-y: auto; border: 1px solid #ccc; margin-bottom: 1rem; }
    li { padding: 0.25rem 0.5rem; cursor: pointer; }
    li.current { font-weight: bold; color: green; background: #f0f0f0; }
    button, input { margin-top: 0.5rem; margin-right: 0.5rem; }
    #progressContainer { width: 100%; height: 10px; background: #ccc; border-radius: 5px; overflow: hidden; margin-top: 0.5rem; }
    #progressBar { width: 0; height: 100%; background: green; }
    #status { margin-bottom: 0.5rem; }
    @media (max-width: 500px) { body { padding: 1rem; } ul { max-height: 150px; } }
  </style>
</head>
<body>
  <h1>DFPWM Radio</h1>
  <p id="status">Loading playlist...</p>
  <ul id="trackList"></ul>

  <div>
    <button id="prevBtn" disabled>‚èÆ Previous</button>
    <button id="playBtn" disabled>‚ñ∂ Play</button>
    <button id="nextBtn" disabled>‚è≠ Next</button>
    <button id="shuffleBtn" disabled>üîÄ Shuffle Off</button>
  </div>

  <div>
    Volume: <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.5">
  </div>

  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="timeDisplay">00:00 / 00:00</div>

  <script type="module">
    import { DfpwmDecoder } from "./js/dfpwm.min.js";

    const GITHUB_USER = "TheMisterCat";
    const GITHUB_REPO = "pants";
    const BRANCH = "main";

    const STATUS = document.getElementById("status");
    const PLAY_BTN = document.getElementById("playBtn");
    const PREV_BTN = document.getElementById("prevBtn");
    const NEXT_BTN = document.getElementById("nextBtn");
    const SHUFFLE_BTN = document.getElementById("shuffleBtn");
    const TRACK_LIST_EL = document.getElementById("trackList");
    const VOLUME_CTRL = document.getElementById("volumeControl");
    const PROGRESS_BAR = document.getElementById("progressBar");
    const TIME_DISPLAY = document.getElementById("timeDisplay");

    let playlist = [];
    let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let gainNode = audioCtx.createGain();
    gainNode.connect(audioCtx.destination);
    gainNode.gain.value = parseFloat(VOLUME_CTRL.value);

    let currentIndex = 0;
    let isPlaying = false;
    let shuffleMode = false;
    let sourceQueue = [];
    let currentBuffer = null;
    let currentTimeOffset = 0;
    const CHUNK_SIZE = 44100 * 2; // 2 seconds per chunk

    VOLUME_CTRL.addEventListener("input", () => {
      gainNode.gain.value = parseFloat(VOLUME_CTRL.value);
    });

    SHUFFLE_BTN.addEventListener("click", () => {
      shuffleMode = !shuffleMode;
      SHUFFLE_BTN.textContent = shuffleMode ? "üîÄ Shuffle On" : "üîÄ Shuffle Off";
    });

    PREV_BTN.addEventListener("click", () => { currentIndex = (currentIndex - 1 + playlist.length) % playlist.length; startTrack(); });
    NEXT_BTN.addEventListener("click", () => { currentIndex = (currentIndex + 1) % playlist.length; startTrack(); });

    PLAY_BTN.addEventListener("click", () => {
      if(!isPlaying) startTrack(); else stopTrack();
    });

    document.addEventListener("keydown", e => {
      if(e.code === "Space") { e.preventDefault(); PLAY_BTN.click(); }
      else if(e.code === "ArrowRight") NEXT_BTN.click();
      else if(e.code === "ArrowLeft") PREV_BTN.click();
    });

    function displayTrackList() {
      TRACK_LIST_EL.innerHTML = "";
      playlist.forEach((track, i) => {
        const li = document.createElement("li");
        li.textContent = track.name;
        li.dataset.index = i;
        li.addEventListener("click", () => { currentIndex = i; startTrack(); });
        TRACK_LIST_EL.appendChild(li);
      });
    }

    function highlightTrack(index) {
      TRACK_LIST_EL.querySelectorAll("li").forEach(li => li.classList.remove("current"));
      const currentLi = TRACK_LIST_EL.querySelector(`li[data-index="${index}"]`);
      if(currentLi) currentLi.classList.add("current");
    }

    async function fetchPlaylist() {
      try {
        const apiUrl = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents?ref=${BRANCH}`;
        const res = await fetch(apiUrl);
        const files = await res.json();
        playlist = files.filter(f => f.name.endsWith(".dfpwm")).map(f => ({ name: f.name, url: f.download_url }));
        if(!playlist.length) { STATUS.textContent = "No DFPWM files found!"; return; }
        STATUS.textContent = `Found ${playlist.length} tracks.`;
        PLAY_BTN.disabled = false; PREV_BTN.disabled = false; NEXT_BTN.disabled = false; SHUFFLE_BTN.disabled = false;
        displayTrackList();
      } catch(err) { STATUS.textContent = "Failed to load playlist: " + err; }
    }

    async function fetchDfpwm(url) {
      const res = await fetch(url);
      const arrayBuffer = await res.arrayBuffer();
      return new Uint8Array(arrayBuffer);
    }

    async function startTrack() {
      stopTrack();
      const track = playlist[currentIndex];
      highlightTrack(currentIndex);
      STATUS.textContent = `Playing: ${track.name}`;
      const bytes = await fetchDfpwm(track.url);
      const decoder = new DfpwmDecoder();
      const audioData = decoder.decode(bytes);

      currentBuffer = audioData;
      currentTimeOffset = 0;
      isPlaying = true;
      PLAY_BTN.textContent = "‚è∏ Pause";

      playNextChunk();
    }

    function playNextChunk() {
      if(!isPlaying || currentTimeOffset >= currentBuffer.length) {
        // Track ended
        isPlaying = false;
        PLAY_BTN.textContent = "‚ñ∂ Play";
        PROGRESS_BAR.style.width = "0%";
        TIME_DISPLAY.textContent = "00:00 / 00:00";
        if(shuffleMode) currentIndex = Math.floor(Math.random() * playlist.length);
        else currentIndex = (currentIndex + 1) % playlist.length;
        startTrack();
        return;
      }

      const chunkEnd = Math.min(currentTimeOffset + CHUNK_SIZE, currentBuffer.length);
      const chunkData = currentBuffer.slice(currentTimeOffset, chunkEnd);

      const bufferNode = audioCtx.createBuffer(1, chunkData.length, 44100);
      bufferNode.getChannelData(0).set(chunkData);

      const source = audioCtx.createBufferSource();
      source.buffer = bufferNode;
      source.connect(gainNode);

      source.onended = () => { currentTimeOffset += CHUNK_SIZE; playNextChunk(); };

      source.start();
      sourceQueue.push(source);

      // Update progress
      const totalDuration = currentBuffer.length / 44100;
      const elapsed = currentTimeOffset / 44100;
      PROGRESS_BAR.style.width = Math.min((elapsed / totalDuration) * 100, 100) + "%";
      TIME_DISPLAY.textContent = formatTime(elapsed) + " / " + formatTime(totalDuration);

      requestAnimationFrame(() => {
        if(isPlaying) playNextChunk(); // schedule next if needed
      });
    }

    function stopTrack() {
      isPlaying = false;
      PLAY_BTN.textContent = "‚ñ∂ Play";
      sourceQueue.forEach(s => s.stop());
      sourceQueue = [];
    }

    function formatTime(sec) {
      const m = Math.floor(sec / 60).toString().padStart(2,"0");
      const s = Math.floor(sec % 60).toString().padStart(2,"0");
      return `${m}:${s}`;
    }

    await fetchPlaylist();
  </script>
</body>
</html>
