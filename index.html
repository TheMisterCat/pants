<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SMRT Radio</title>
<link rel="icon" href="data:,">
<style>
  body {
    font-family: sans-serif;
    background: #111;
    color: #eee;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  header {
    text-align: center;
    margin: 1em;
  }
  #controls {
    display: flex;
    gap: 10px;
    margin: 1em;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }
  button {
    padding: 0.5em 1em;
    background: #222;
    border: 1px solid #444;
    border-radius: 0.5em;
    color: #eee;
    cursor: pointer;
    transition: background 0.2s;
  }
  button:hover {
    background: #333;
  }
  #sliders {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
  }
  #playlist {
    margin-top: 1em;
    width: 90%;
    max-width: 800px;
    overflow-y: auto;
    max-height: 300px;
  }
  .track {
    padding: 0.5em;
    cursor: pointer;
    border-bottom: 1px solid #444;
  }
  .track.playing {
    background: #333;
  }
  #progress {
    width: 300px;
    margin-top: 1em;
  }
  #waveform {
    width: 90%;
    max-width: 800px;
    height: 100px;
    background: #222;
    margin-top: 1em;
  }
</style>
</head>
<body>
<header><h1>SMRT Radio</h1></header>

<div id="controls">
  <button id="prev">‚èÆÔ∏è Prev</button>
  <button id="play">‚ñ∂Ô∏è Play</button>
  <button id="stop">‚èπÔ∏è Stop</button>
  <button id="next">Next ‚è≠Ô∏è</button>
  <div id="sliders">
    <label>üîä Volume:
      <input type="range" id="volume" min="0" max="1" step="0.01" value="0.2">
    </label>
    <label>üéöÔ∏è Low-pass:
      <input type="range" id="filter" min="500" max="20000" step="100" value="12000">
    </label>
  </div>
</div>

<progress id="progress" value="0" max="1"></progress>
<canvas id="waveform"></canvas>
<div id="playlist"></div>

<script type="module">
// --- CONFIG ---
const REPO = "TheMisterCat/pants";
const AUDIO_DIR = "";
const VOLUME_SCALING = 0.2;

// --- AUDIO SETUP ---
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const masterGainNode = audioContext.createGain();
const filterNode = audioContext.createBiquadFilter();
filterNode.type = "lowpass";
filterNode.frequency.value = 12000;
masterGainNode.connect(filterNode);
filterNode.connect(audioContext.destination);

const analyser = audioContext.createAnalyser();
analyser.fftSize = 2048;
filterNode.connect(analyser);

// --- STATE ---
let currentSource = null;
let currentTrackIndex = 0;
let trackBuffers = [];
let playlist = [];
let lastButtonTime = 0;
const BUTTON_COOLDOWN = 250;
let userStopped = false;

const {Buffer} = require("buffer");
const {Transform} = require("stream");

const CONST_PREC = 10;
const CONST_POSTFILT = 140;

// DFPWM transcoder from https://github.com/ChenThread/dfpwm/blob/master/1a/

class Encoder extends Transform {
    /**
     * Creates a new encoder.
     * @param {number?} q
     * @param {number?} s
     * @param {number?} lt
     */
    constructor(q, s, lt) {
        super();
        if (q !== undefined && q !== null && typeof q !== "number") throw TypeError("Argument #1 must be a number.");
        if (s !== undefined && s !== null && typeof s !== "number") throw TypeError("Argument #2 must be a number.");
        if (lt !== undefined && lt !== null && typeof lt !== "number") throw TypeError("Argument #3 must be a number.");
        this.q = q || 0;
        this.s = s || 0;
        this.lt = lt || -128;
        this.pending = null;
    }
    /**
     * Encodes a buffer of 8-bit signed PCM data to 1-bit DFPWM.
     * @param {Buffer} buffer The PCM buffer to encode.
     * @param {boolean?} final Whether this is the last chunk.
     * @returns {Buffer} The resulting DFPWM data.
     */
    encode(buffer, final) {
        if (!(buffer instanceof Buffer)) throw TypeError("Argument #1 must be a Buffer.");
        let buf = buffer;
        if (this.pending) buf = Buffer.concat([this.pending, buffer]);
        if (buf.length % 8 < 1) final = false;
        const len = (final ? Math.ceil : Math.floor)(buf.length / 8);
        let output = Buffer.alloc(len);
        for (let i = 0; i < len; i++) {
            let d = 0;
            for (let j = 0; j < (final && i === len - 1 ? buf.length % 8 : 8); j++) {
                // get sample
                let v = buf.readInt8(i*8+j);
                // set bit / target
                let t = (v > this.q || (v === this.q && v === 127) ? 127 : -128);
                d >>= 1;
                if (t > 0) d |= 0x80;

                // adjust charge
                let nq = this.q + ((this.s * (t-this.q) + (1<<(CONST_PREC-1)))>>CONST_PREC);
                if (nq === this.q && nq !== t) nq += (t === 127 ? 1 : -1);
                this.q = nq;

                // adjust strength
                let st = (t !== this.lt ? 0 : (1<<CONST_PREC)-1);
                let ns = this.s;
                if (ns !== st) ns += (st !== 0 ? 1 : -1);
                if (CONST_PREC > 8 && ns < (1<<(CONST_PREC-7))) ns = (1<<(CONST_PREC-7));
                this.s = ns;

                this.lt = t;
            }

            // output bits
            if (final && i === len - 1) d >>= 8 - (buf.length % 8);
            output.writeUInt8(d, i);
        }
        if (!final && buf.length % 8 > 0) this.pending = buf.subarray(-(buf.length % 8));
        else this.pending = null;
        return output;
    }

    _transform(chunk, encoding, callback) {
        callback(null, this.encode(chunk));
    }

    _flush(callback) {
        if (this.pending !== null) callback(null, this.encode(Buffer.alloc(0), true));
    }
}

class Decoder extends Transform {
    /**
     * Creates a new decoder.
     * @param {number?} fq
     * @param {number?} q
     * @param {number?} s
     * @param {number?} lt
     */
    constructor(fq, q, s, lt) {
        super();
        if (fq !== undefined && fq !== null && typeof fq !== "number") throw TypeError("Argument #1 must be a number.");
        if (q !== undefined && q !== null && typeof q !== "number") throw TypeError("Argument #2 must be a number.");
        if (s !== undefined && s !== null && typeof s !== "number") throw TypeError("Argument #3 must be a number.");
        if (lt !== undefined && lt !== null && typeof lt !== "number") throw TypeError("Argument #4 must be a number.");
        this.fq = fq || 0;
        this.q = q || 0;
        this.s = s || 0;
        this.lt = lt || -128;
    }
    /**
     * Encodes a buffer of 1-bit DFPWM data to 8-bit signed PCM.
     * @param {Buffer} buffer The DFPWM buffer to decode.
     * @param {number?} fs
     * @returns {Buffer} The resulting PCM data.
     */
    decode(buffer, fs) {
        if (!(buffer instanceof Buffer)) throw TypeError("Argument #1 must be a Buffer.");
        if (fs !== undefined && fs !== null && typeof fs !== "number") throw TypeError("Argument #2 must be a number.");
        fs = fs || CONST_POSTFILT;
        let inpos = 0;
        let outpos = 0;
        let output = Buffer.alloc(buffer.length * 8);
        for (let i = 0; i < buffer.length; i++) {
            // get bits
            let d = buffer.readUInt8(inpos++);
            for (let j = 0; j < 8; j++) {
                // set target
                let t = ((d&1) ? 127 : -128);
                d >>= 1;

                // adjust charge
                let nq = this.q + ((this.s * (t-this.q) + (1<<(CONST_PREC-1)))>>CONST_PREC);
                if (nq === this.q && nq !== t) this.q += (t === 127 ? 1 : -1);
                let lq = this.q;
                this.q = nq;

                // adjust strength
                let st = (t !== this.lt ? 0 : (1<<CONST_PREC)-1);
                let ns = this.s;
                if (ns !== st) ns += (st !== 0 ? 1 : -1);
                if (CONST_PREC > 8 && ns < (1<<(CONST_PREC-7))) ns = (1<<(CONST_PREC-7));
                this.s = ns;

                // FILTER: perform antijerk
                let ov = (t !== this.lt ? (nq+lq+1)>>1 : nq);

                // FILTER: perform LPF
                this.fq += ((fs*(ov-this.fq) + 0x80)>>8);
                ov = this.fq;

                // output sample
                output.writeInt8(ov, outpos++);

                this.lt = t;
            }
        }
        return output;
    }

    _transform(chunk, encoding, callback) {
        callback(null, decode(chunk));
    }
}

/**
 * Quickly encodes a single chunk of PCM audio to DFPWM.
 * @param {Buffer} buffer The PCM buffer to encode.
 * @returns {Buffer} The resulting DFPWM data.
 */
function encode(data) {
    return (new Encoder()).encode(data, true);
}

/**
 * Quickly decodes a single chunk of DFPWM audio to PCM.
 * @param {Buffer} buffer The DFPWM buffer to decode.
 * @param {number?} fs
 * @returns {Buffer} The resulting PCM data.
 */
function decode(data, fs = 0xFF) {
    return (new Decoder()).decode(data, fs);
}

module.exports = {
    Decoder: Decoder,
    Encoder: Encoder,
    quickEncode: encode,
    quickDecode: decode
};

// --- FETCH PLAYLIST ---
async function fetchPlaylist() {
  const url = `https://api.github.com/repos/${REPO}/contents/${AUDIO_DIR}`;
  const res = await fetch(url);
  const files = await res.json();
  playlist = files.filter(f => f.name.endsWith(".dfpwm")).map(f => f.name);
  const listDiv = document.getElementById("playlist");
  listDiv.innerHTML = "";
  playlist.forEach((name, idx) => {
    const div = document.createElement("div");
    div.textContent = name;
    div.classList.add("track");
    div.onclick = () => safePlay(idx);
    listDiv.appendChild(div);
  });
}

// --- LOAD & DECODE ---
async function loadTrack(idx) {
  const url = `https://raw.githubusercontent.com/${REPO}/main/${AUDIO_DIR}${playlist[idx]}`;
  const res = await fetch(url);
  const bytes = new Uint8Array(await res.arrayBuffer());
  const floatData = decode(bytes);
  const buffer = audioContext.createBuffer(1, floatData.length, 48000);
  buffer.copyToChannel(floatData, 0, 0);
  trackBuffers[idx] = buffer;
}

// --- PLAYBACK ---
async function playTrack(idx) {
  if (currentSource) { userStopped = true; currentSource.stop(); }
  currentTrackIndex = idx;
  highlightPlaying();
  if (!trackBuffers[idx]) await loadTrack(idx);

  const source = audioContext.createBufferSource();
  source.buffer = trackBuffers[idx];
  source.connect(masterGainNode);
  currentSource = source;
  userStopped = false;

  source.start(0);
  source.onended = () => {
    currentSource = null;
    if (!userStopped) nextTrack();
  };
}

function stopTrack() {
  if (currentSource) {
    userStopped = true;
    currentSource.stop();
    currentSource = null;
  }
}
function nextTrack() {
  if (!playlist.length) return;
  userStopped = true;
  if (currentSource) currentSource.stop();
  const next = (currentTrackIndex + 1) % playlist.length;
  playTrack(next);
}
function prevTrack() {
  if (!playlist.length) return;
  userStopped = true;
  if (currentSource) currentSource.stop();
  const prev = (currentTrackIndex - 1 + playlist.length) % playlist.length;
  playTrack(prev);
}

// --- SAFETY WRAPPERS ---
function safeAction(action) {
  const now = performance.now();
  if (now - lastButtonTime < BUTTON_COOLDOWN) return;
  lastButtonTime = now;
  action();
}
function safePlay(idx) {
  safeAction(() => {
    userStopped = true;
    if (currentSource) currentSource.stop();
    playTrack(idx);
  });
}
function safeStop() { safeAction(stopTrack); }
function safeNext() { safeAction(nextTrack); }
function safePrev() { safeAction(prevTrack); }

function highlightPlaying() {
  document.querySelectorAll(".track").forEach((el, idx) => {
    el.classList.toggle("playing", idx === currentTrackIndex);
  });
}

// --- UI LISTENERS ---
document.getElementById("play").onclick = () => safePlay(currentTrackIndex);
document.getElementById("stop").onclick = safeStop;
document.getElementById("next").onclick = safeNext;
document.getElementById("prev").onclick = safePrev;

// --- SLIDERS ---
const volumeSlider = document.getElementById("volume");
const filterSlider = document.getElementById("filter");

volumeSlider.addEventListener("input", e => {
  masterGainNode.gain.value = parseFloat(e.target.value);
});
filterSlider.addEventListener("input", e => {
  filterNode.frequency.value = parseFloat(e.target.value);
});

// Apply initial slider values immediately
masterGainNode.gain.value = parseFloat(volumeSlider.value);
filterNode.frequency.value = parseFloat(filterSlider.value);

// --- VISUALIZER ---
const canvas = document.getElementById("waveform");
const ctx = canvas.getContext("2d");
function drawWaveform() {
  requestAnimationFrame(drawWaveform);
  const bufferLength = analyser.fftSize;
  const dataArray = new Uint8Array(bufferLength);
  analyser.getByteTimeDomainData(dataArray);
  ctx.fillStyle = "#222";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#0f0";
  ctx.beginPath();
  const sliceWidth = canvas.width / bufferLength;
  let x = 0;
  for (let i = 0; i < bufferLength; i++) {
    const v = dataArray[i] / 128.0;
    const y = v * canvas.height / 2;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
    x += sliceWidth;
  }
  ctx.lineTo(canvas.width, canvas.height / 2);
  ctx.stroke();
}
drawWaveform();

// --- INIT ---
fetchPlaylist();
</script>
</body>
</html>
