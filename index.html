<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>SMRT Radio</title>
<style>
  body { font-family: sans-serif; margin: 2em; }
  #controls button { margin: 0.2em; }
  #volume { width: 150px; }
  #progressContainer { width: 300px; height: 10px; background: #ddd; margin-top: 0.5em; position: relative; }
  #progress { height: 100%; width: 0%; background: #3a9; }
  #trackList li { cursor: pointer; }
  #trackList li.current { font-weight: bold; }
</style>
</head>
<body>
<h1>DFPWM Radio</h1>

<!-- Controls at top -->
<div id="controls">
  <button id="prev">Prev</button>
  <button id="playPause">Play</button>
  <button id="stop">Stop</button>
  <button id="next">Next</button>
  Volume: <input type="range" id="volume" min="0" max="1" step="0.01" value="0.25">
</div>

<!-- Progress bar -->
<div id="progressContainer">
  <div id="progress"></div>
</div>

<!-- Track list at bottom -->
<ul id="trackList"></ul>

<script type="module">
// ==================== DFPWM Decoder ====================
export function decodeDFPWM(bytes) {
  let charge = 0;
  const strength = 0.25; 
  const output = new Float32Array(bytes.length * 8);
  let sampleIndex = 0;
  const fadeSamples = 32;

  for (let byte of bytes) {
    for (let i = 0; i < 8; i++) {
      const bit = (byte >> i) & 1;
      const target = bit ? 1 : -1;
      charge += (target - charge) * strength;

      const fadeFactor = sampleIndex < fadeSamples ? sampleIndex / fadeSamples : 1;
      output[sampleIndex++] = Math.max(-1, Math.min(1, charge)) * 0.3 * fadeFactor; // normalized
    }
  }
  return output;
}

// ==================== Player Script ====================
const USER = "TheMisterCat";
const REPO = "pants";
const BRANCH = "main";

let playlist = [];
let currentIndex = 0;

let audioCtx = null;
let gainNode = null;
let source = null;

let isPlaying = false;
let isLoadingTrack = false; // <— prevents multiple simultaneous loads
let trackStartTime = 0;
let pauseOffset = 0;
let trackDuration = 0;
let progressInterval = null;

const trackListEl = document.getElementById("trackList");
const playPauseBtn = document.getElementById("playPause");
const volumeSlider = document.getElementById("volume");
const progressBar = document.getElementById("progress");

// ==================== Playlist ====================
async function fetchPlaylist() {
  const res = await fetch(`https://api.github.com/repos/${USER}/${REPO}/contents?ref=${BRANCH}`);
  const files = await res.json();
  playlist = files.filter(f => f.name.endsWith(".dfpwm")).map(f => f.name);

  trackListEl.innerHTML = "";
  playlist.forEach((name, idx) => {
    const li = document.createElement("li");
    li.textContent = name;
    li.addEventListener("click", () => playTrack(idx));
    trackListEl.appendChild(li);
  });
}

// ==================== Audio Helpers ====================
async function fetchTrackPCM(trackName) {
  const url = `https://raw.githubusercontent.com/${USER}/${REPO}/${BRANCH}/${trackName}`;
  const res = await fetch(url);
  const buffer = new Uint8Array(await res.arrayBuffer());
  return decodeDFPWM(buffer);
}

function createSource(pcm) {
  const audioBuffer = audioCtx.createBuffer(1, pcm.length, 48000);
  audioBuffer.getChannelData(0).set(pcm);

  const newSource = audioCtx.createBufferSource();
  newSource.buffer = audioBuffer;
  newSource.connect(gainNode);
  newSource.onended = playNextTrack;

  return { newSource, duration: audioBuffer.duration };
}

// ==================== Playback ====================
async function playTrack(index) {
  if (isLoadingTrack) return; // <— ignore clicks while loading
  isLoadingTrack = true;

  stopTrack(); // stop any existing track
  currentIndex = index;
  highlightCurrentTrack();

  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    gainNode = audioCtx.createGain();
    gainNode.gain.value = parseFloat(volumeSlider.value);
    gainNode.connect(audioCtx.destination);
  }

  try {
    const pcm = await fetchTrackPCM(playlist[currentIndex]);
    const { newSource, duration } = createSource(pcm);

    source = newSource;
    trackDuration = duration;

    source.start(0, pauseOffset);
    trackStartTime = audioCtx.currentTime - pauseOffset;
    pauseOffset = 0;
    isPlaying = true;

    startProgressUpdater();
    playPauseBtn.textContent = "Pause";
  } finally {
    isLoadingTrack = false; // release lock even if fetch fails
  }
}

function stopTrack() {
  if (source) {
    source.stop();
    source.disconnect();
    source = null;
  }
  pauseOffset = 0;
  isPlaying = false;
  stopProgressUpdater();
  playPauseBtn.textContent = "Play";
}

function pauseTrack() {
  if (source && isPlaying) {
    source.stop();
    source.disconnect();
    pauseOffset = audioCtx.currentTime - trackStartTime;
    source = null;
    isPlaying = false;
    stopProgressUpdater();
    playPauseBtn.textContent = "Play";
  }
}

function playNextTrack() {
  currentIndex = (currentIndex + 1) % playlist.length;
  playTrack(currentIndex);
}

function playPrevTrack() {
  currentIndex = (currentIndex - 1 + playlist.length) % playlist.length;
  playTrack(currentIndex);
}

function highlightCurrentTrack() {
  Array.from(trackListEl.children).forEach((li, idx) => {
    li.classList.toggle("current", idx === currentIndex);
  });
}

// ==================== Progress ====================
function startProgressUpdater() {
  stopProgressUpdater();
  progressInterval = setInterval(() => {
    if (!isPlaying) return;
    const elapsed = audioCtx.currentTime - trackStartTime;
    const percent = Math.min(1, elapsed / trackDuration) * 100;
    progressBar.style.width = percent + "%";
  }, 100);
}

function stopProgressUpdater() {
  if (progressInterval) clearInterval(progressInterval);
  progressBar.style.width = "0%";
}

// ==================== Controls ====================
playPauseBtn.addEventListener("click", () => {
  if (isPlaying) pauseTrack();
  else playTrack(currentIndex);
});

document.getElementById("next").addEventListener("click", playNextTrack);
document.getElementById("prev").addEventListener("click", playPrevTrack);
document.getElementById("stop").addEventListener("click", stopTrack);

volumeSlider.addEventListener("input", (e) => {
  if (gainNode) gainNode.gain.value = parseFloat(e.target.value);
});

// ==================== Init ====================
fetchPlaylist();
</script>
</body>
</html>
