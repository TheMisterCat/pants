<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SMRT Radio</title>
<style>
  body { font-family: sans-serif; background: #121212; color: #eee; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 0; }
  h1 { margin: 1em 0; }
  #controls { display: flex; align-items: center; gap: 1em; margin-bottom: 1em; }
  button { padding: 0.5em 1em; }
  #volume, #filterFreq, #progress { width: 200px; }
  #playlist { margin-top: 1em; width: 80%; max-width: 600px; }
  #playlist div { padding: 0.5em; cursor: pointer; border-bottom: 1px solid #333; }
  #playlist .playing { background: #333; }
</style>
</head>
<body>
<h1>SMRT Radio</h1>
<div id="controls">
  <button id="prev">Prev</button>
  <button id="playPause">Play</button>
  <button id="stop">Stop</button>
  <button id="next">Next</button>
  <label>Volume:<input type="range" id="volume" min="0" max="1" step="0.01" value="0.5"></label>
  <label>Treble:<input type="range" id="filterFreq" min="500" max="8000" step="10" value="4000"></label>
</div>
<input type="range" id="progress" min="0" max="1" step="0.001" value="0">
<div id="playlist"></div>

<script>
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
let masterGainNode = audioContext.createGain();
masterGainNode.gain.value = 0.3; // reduced to avoid oversaturation
masterGainNode.connect(audioContext.destination);

let trackList = [
  "track1.dfpwm",
  "track2.dfpwm",
  "track3.dfpwm"
]; // Replace with actual GitHub DFPWM file URLs
let trackBuffers = {};
let currentSource = null;
let currentTrackIndex = 0;
let isPlaying = false;

const volumeSlider = document.getElementById("volume");
const filterSlider = document.getElementById("filterFreq");
const progressSlider = document.getElementById("progress");
const playlistDiv = document.getElementById("playlist");

function stopCurrentTrack() {
  if (currentSource) {
    currentSource.stop();
    currentSource.disconnect();
    currentSource = null;
  }
  isPlaying = false;
  updatePlayButton();
}

function highlightPlaying() {
  Array.from(playlistDiv.children).forEach((el, i) => {
    el.classList.toggle("playing", i === currentTrackIndex);
  });
}

async function loadTrack(idx) {
  if (trackBuffers[idx]) return trackBuffers[idx];
  const url = trackList[idx];
  const response = await fetch(url);
  const dfpwmData = new Uint8Array(await response.arrayBuffer());
  // Decode using AUKit-inspired JS decoder
  const wavBuffer = dfpwmDecodeToPCM(dfpwmData);
  const audioBuffer = await audioContext.decodeAudioData(wavBuffer.buffer);
  trackBuffers[idx] = audioBuffer;
  return audioBuffer;
}

// Simple AUKit-inspired DFPWM decoder placeholder
function dfpwmDecodeToPCM(dfpwm) {
  // Implement or port AUKit decoding here
  // For demo, just returning silent buffer
  return new Float32Array(dfpwm.length * 4); 
}

function playTrack(idx) {
  stopCurrentTrack();
  currentTrackIndex = idx;
  highlightPlaying();

  loadTrack(idx).then(buffer => {
    const source = audioContext.createBufferSource();
    source.buffer = buffer;

    // Two-stage smoothing filter
    const filter1 = audioContext.createBiquadFilter();
    filter1.type = "lowpass";
    filter1.frequency.value = filterSlider.value;

    const filter2 = audioContext.createBiquadFilter();
    filter2.type = "lowpass";
    filter2.frequency.value = filterSlider.value;

    source.connect(filter1);
    filter1.connect(filter2);
    filter2.connect(masterGainNode);

    source.start(0);
    currentSource = source;
    isPlaying = true;
    updatePlayButton();

    source.onended = () => {
      currentSource = null;
      isPlaying = false;
      updatePlayButton();
      nextTrack();
    };
  });
}

function playPauseTrack() {
  if (isPlaying) {
    stopCurrentTrack();
  } else {
    playTrack(currentTrackIndex);
  }
}

function nextTrack() {
  let nextIdx = (currentTrackIndex + 1) % trackList.length;
  playTrack(nextIdx);
}

function prevTrack() {
  let prevIdx = (currentTrackIndex - 1 + trackList.length) % trackList.length;
  playTrack(prevIdx);
}

function updatePlayButton() {
  document.getElementById("playPause").textContent = isPlaying ? "Pause" : "Play";
}

volumeSlider.addEventListener("input", () => {
  masterGainNode.gain.value = volumeSlider.value;
});

filterSlider.addEventListener("input", () => {
  // filter frequency is updated dynamically per new track
});

document.getElementById("playPause").addEventListener("click", playPauseTrack);
document.getElementById("stop").addEventListener("click", stopCurrentTrack);
document.getElementById("next").addEventListener("click", nextTrack);
document.getElementById("prev").addEventListener("click", prevTrack);

// Populate playlist
trackList.forEach((name, i) => {
  const div = document.createElement("div");
  div.textContent = name;
  div.addEventListener("click", () => playTrack(i));
  playlistDiv.appendChild(div);
});

// Optional: progress bar updates (basic, not linked to exact sample position)
setInterval(() => {
  progressSlider.value = isPlaying ? (audioContext.currentTime % 10) / 10 : 0;
}, 200);

</script>
</body>
</html>
